pipeline {
  agent any

  environment {
    REPO_URL     = 'git@github.com:Xtute-Technologies/tutorlix_next.git'
    BRANCH       = 'main'
    DEPLOY_PATH  = '/var/lib/jenkins/workspace/tutorlix_frontend_main'
    COMPOSE_FILE = 'docker-compose.yml'
    BUILD_DIR    = 'dist'
    PIN_PLUGIN_VERSION = '1.1.0'   // standalone-single-spa-webpack-plugin (CJS)
    AJV_PIN      = '6.12.6'        // ajv pin to satisfy older consumers
    AJV_KEYWORDS_PIN = '3.5.2'    // ajv-keywords compatible with ajv@6
    NGINX_USER   = 'www-data'
  }

  stages {
    stage('Checkout') {
      steps {
        git branch: "${BRANCH}", credentialsId: 'github-ssh-key', url: "${REPO_URL}"
      }
    }

    stage('Prepare Node / Install (pin plugin + ajv + ajv-keywords)') {
      steps {
        sh '''
          set -eu

          echo "Node/npm versions:"
          node -v || true
          npm -v || true

          # Use legacy peer deps to avoid peer resolution halts in CI
          npm config set legacy-peer-deps true

          echo "Cleaning previous installs..."
          rm -rf node_modules package-lock.json

          echo "Pinning required packages exactly (ajv, ajv-keywords, standalone plugin)..."
          # Install exact versions as top-level dependencies (no-save to avoid editing package.json if you prefer)
          # We use --no-audit/--no-fund to speed things up in CI.
          npm install --no-audit --no-fund --save-exact ajv@${AJV_PIN} ajv-keywords@${AJV_KEYWORDS_PIN} standalone-single-spa-webpack-plugin@${PIN_PLUGIN_VERSION}

          echo "Installing full dependency tree (legacy-peer-deps)..."
          npm install --legacy-peer-deps --no-audit --no-fund

          echo "Installed top-level versions (sanity checks):"
          npm ls ajv ajv-keywords standalone-single-spa-webpack-plugin --depth=0 || true
        '''
      }
    }

    stage('Build Single-SPA Root') {
      steps {
        sh '''
          set -eu

          echo "üèóÔ∏è Building single-spa root app (webpack will emit to ./dist at repo root)..."
          npm run build

          if [ -d ./dist ]; then
            echo "Ensuring ./dist is writable by jenkins..."
            # best-effort: try chown; allow sudo in CI
            id -u jenkins >/dev/null 2>&1 && chown -R jenkins:jenkins ./dist || true
            # fallback with sudo if previous failed (works if Jenkins agent has sudo)
            sudo chown -R jenkins:jenkins ./dist || true
            sudo chmod -R 755 ./dist || true
          fi

          # Ensure importmap.json exists in repo root and copy it into dist (so server serves it)
          if [ -f ./importmap.json ]; then
            echo "Copying importmap.json into dist/"
            cp ./importmap.json ./dist/importmap.json
          else
            echo "Warning: importmap.json not found at repo root; ensure CI provides it or pipeline will 404"
          fi

          cd ${WORKSPACE}/dist

          # create a stable symlink for the latest hashed chunk (if hashed filename exists)
          latest=$(ls -1t tutorlix-root-config.*.js 2>/dev/null | head -n1 || true)
          if [ -n "$latest" ]; then
            ln -sf "$latest" tutorlix-root-config.js
            echo "Linked $latest -> tutorlix-root-config.js"
          else
            if [ -f "tutorlix-root-config.js" ]; then
              echo "Found tutorlix-root-config.js (non-hashed)."
            else
              echo "ERROR: No tutorlix-root-config.*.js or tutorlix-root-config.js found in dist"
              exit 1
            fi
          fi
          sed -i 's|localhost:10001|dev.tutorlix.com|g' ./dist/importmap.json
          echo "‚úÖ Build complete. Files in ./dist:"
          ls -lah ./ || true
        '''
      }
    }

    stage('Deploy Locally') {
      steps {
        sh '''
          set -eu

          echo "üöö Deploying build to ${DEPLOY_PATH}..."

          sudo mkdir -p "${DEPLOY_PATH}"
          FRONTEND_DIR="${DEPLOY_PATH}/frontend"
          sudo rm -rf "${FRONTEND_DIR}" || true
          sudo mkdir -p "${FRONTEND_DIR}"

          echo "Copying built artifacts into ${FRONTEND_DIR}..."
          sudo cp -a "${WORKSPACE}/dist/." "${FRONTEND_DIR}/"

          if sudo test -f "${FRONTEND_DIR}/importmap.json"; then
            echo "importmap.json found in deployed frontend."
          else
            echo "Warning: importmap.json missing in deployed frontend; nginx will return 404 for /importmap.json"
          fi

          sudo chown -R ${NGINX_USER}:${NGINX_USER} "${FRONTEND_DIR}"
          sudo chmod -R 755 "${FRONTEND_DIR}"

          echo "--- ${DEPLOY_PATH} contents ---"
          sudo ls -la "${DEPLOY_PATH}" || true
          echo "--- ${FRONTEND_DIR} contents ---"
          sudo ls -la "${FRONTEND_DIR}" || true

          if [ -f "${DEPLOY_PATH}/${COMPOSE_FILE}" ]; then
            cd "${DEPLOY_PATH}"
            docker compose -f "${COMPOSE_FILE}" down || true
            docker compose -f "${COMPOSE_FILE}" build --no-cache
            docker compose -f "${COMPOSE_FILE}" up -d --remove-orphans
            echo "‚úÖ Docker compose started."
          else
            echo "No ${COMPOSE_FILE} at ${DEPLOY_PATH}; skipping docker compose."
          fi

          echo "‚úÖ Deployment (files copied)."
        '''
      }
    }

    stage('Restart Nginx') {
      steps {
        sh '''
          echo "‚ôªÔ∏è Restarting Nginx..."
          sudo nginx -t
          sudo systemctl restart nginx
        '''
      }
    }
  }

  post {
    success {
      echo "‚úÖ Single-SPA root app deployed successfully at https://dev.tutorlix.com"
    }
    failure {
      echo "‚ùå Deployment failed. Check Jenkins console output for details."
    }
  }
}
